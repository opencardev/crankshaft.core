# Project: Crankshaft
# This file is part of Crankshaft project.
# Copyright (C) 2025 OpenCarDev Team
#
#  Crankshaft is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  Crankshaft is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Crankshaft. If not, see <http://www.gnu.org/licenses/>.

name: CD

on:
  workflow_run:
    workflows: ["CI"]
    branches:
      - main
    types:
      - completed

  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Build run ID from CI workflow (optional, uses latest CI success if empty)'
        required: false
        type: string
      distribution:
        description: 'Distribution to publish to'
        required: false
        default: 'trixie'
        type: choice
        options:
          - trixie
          - bookworm
          - both
      amd64only:
        description: 'Test amd64 only (skip ARM for fast debugging)'
        required: false
        default: false
        type: boolean

permissions:
  actions: write
  contents: read

jobs:
  publish-apt:
    runs-on: ubuntu-latest
    if: ${{ (github.event.workflow_run.conclusion == 'success' && github.event_name == 'workflow_run' ) || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Trigger APT Repository Update
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Triggering APT publish');
            let runId = (context.payload.workflow_run && context.payload.workflow_run.id) || (context.payload.inputs && context.payload.inputs.build_run_id) || '';
            // Fallback: lookup latest successful CI run on main when runId is empty
            if (!runId) {
              const workflows = await github.rest.actions.listRepoWorkflows({ owner: context.repo.owner, repo: context.repo.repo });
              const ciWf = workflows.data.workflows.find(w => w.name === 'CI');
              if (!ciWf) { throw new Error('CI workflow not found'); }
              const runs = await github.rest.actions.listWorkflowRuns({ owner: context.repo.owner, repo: context.repo.repo, workflow_id: ciWf.id, branch: 'main', status: 'success', per_page: 1 });
              if (runs.data.workflow_runs && runs.data.workflow_runs.length > 0) {
                runId = String(runs.data.workflow_runs[0].id);
                console.log(`Resolved latest successful CI runId: ${runId}`);
              } else {
                throw new Error('No successful CI runs found on main');
              }
            }
            // Resolve workflow id for trigger-apt-publish by name
            const list = await github.rest.actions.listRepoWorkflows({ owner: context.repo.owner, repo: context.repo.repo });
            const aptWf = list.data.workflows.find(w => (w.name === 'Trigger APT Repository Update') || (w.path && w.path.endsWith('/trigger-apt-publish.yml')));
            if (!aptWf) { throw new Error('trigger-apt-publish workflow not found'); }
            const dispatchTime = Date.now();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: aptWf.id,
              ref: 'main',
              inputs: {
                build_run_id: String(runId),
                distribution: (context.payload.inputs && context.payload.inputs.distribution) || 'trixie'
              }
            });
            return { workflowId: aptWf.id, dispatchTime };
          result-encoding: json

      - name: Wait for APT publish workflow completion
        uses: actions/github-script@v7
        with:
          script: |
            const { workflowId, dispatchTime } = ${{ steps.trigger.outputs.result }};
            console.log(`Waiting for workflow ${workflowId} triggered at ${dispatchTime}`);
            
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const pollInterval = 10 * 1000; // 10 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              // Get recent runs for the workflow
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                per_page: 5
              });
              
              // Find run that started after our dispatch
              const targetRun = runs.data.workflow_runs.find(run => {
                const runTime = new Date(run.created_at).getTime();
                return runTime >= dispatchTime - 60000; // 1 minute buffer
              });
              
              if (targetRun) {
                console.log(`Found workflow run: ${targetRun.html_url}`);
                console.log(`Status: ${targetRun.status}, Conclusion: ${targetRun.conclusion}`);
                
                if (targetRun.status === 'completed') {
                  if (targetRun.conclusion === 'success') {
                    console.log('✅ APT publish workflow completed successfully!');
                    console.log(`Run URL: ${targetRun.html_url}`);
                    return;
                  } else {
                    throw new Error(`APT publish workflow failed with conclusion: ${targetRun.conclusion}\nURL: ${targetRun.html_url}`);
                  }
                }
              }
              
              console.log('Waiting for workflow to complete...');
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            throw new Error('Timeout waiting for APT publish workflow to complete');

  test-apt-install:
    needs: publish-apt
    runs-on: ubuntu-latest
    if: needs.publish-apt.result == 'success'
    strategy:
      matrix:
        arch: ${{ github.event.inputs.amd64only == 'true' && fromJSON('["amd64"]') || fromJSON('["amd64", "arm64", "armhf"]') }}
        suite: [trixie]
    steps:
      - name: Set up QEMU for multi-arch
        if: matrix.arch != 'amd64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/${{ matrix.arch }}

      - name: Test package installation (Dockerfile)
        run: |
          echo "Waiting 60 seconds for APT repository to be published..."
          sleep 60

          PLATFORM="linux/${{ matrix.arch }}"
          if [ "${{ matrix.arch }}" = "armhf" ]; then
            PLATFORM="linux/arm/v7"
          fi

          echo "Building test image on $PLATFORM with Debian ${{ matrix.suite }}"
          docker buildx build \
            --platform $PLATFORM \
            --build-arg SUITE=${{ matrix.suite }} \
            -t crankshaft-apt-test:${{ matrix.arch }}-${{ matrix.suite }} \
            -f docker/Dockerfile.test . \
            --load

          echo "Running verification script in the test image"
          docker run --platform $PLATFORM --rm crankshaft-apt-test:${{ matrix.arch }}-${{ matrix.suite }}

      - name: Report test result
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ APT installation test passed for ${{ matrix.arch }} on ${{ matrix.suite }}"
          else
            echo "❌ APT installation test failed for ${{ matrix.arch }} on ${{ matrix.suite }}"
            exit 1
          fi

  build-pi-images:
    needs: test-apt-install
    runs-on: ubuntu-latest
    if: needs.test-apt-install.result == 'success'
    steps:
      - name: Trigger Pi-Gen Build
        uses: actions/github-script@v7
        with:
          script: |
            const wr = context.payload.workflow_run || {};
            const headBranch = wr.head_branch || 'main';
            const runNumber = wr.run_number || 0;
            const version = `${headBranch}-${runNumber}`;
            // Resolve workflow id for build-pi-gen-lite by name
            const list = await github.rest.actions.listRepoWorkflows({ owner: context.repo.owner, repo: context.repo.repo });
            const piGenWf = list.data.workflows.find(w => (w.name === 'build-pi-gen-lite') || (w.path && w.path.endsWith('/build-pi-gen-lite.yml')));
            if (!piGenWf) { throw new Error('build-pi-gen-lite workflow not found'); }
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: piGenWf.id,
              ref: 'main',
              inputs: {
                version,
                release: 'trixie',
                auto_release: 'false',
                create_release_draft: 'false'
              }
            });
